= RxSwiftExamples2

===== RxSwift 적용
* UIImage

[source, swift]
----
func getImage(url: URL?) -> UIImage? {
    // ...
}

func getImage(url: URL?, handler: ((UIImage?) -> Void)) -> Void {
    // ...
}

func getImage(url: URL?) -> Observable<UIImage> { 
    // ...
}
----

* TextField

[source, swift]
----
// Before
override func viewDidLoad() {
    super.viewDidLoad()
    textField.addTarget(self,
                        action: #selector(textFieldDidChange(textField:)),
                            for: UIControlEvents.editingChanged)
}

@objc func textFieldDidChange(textField: UITextField){
    label.text = textField.text
}

// After
override func viewDidLoad() {
    textField.rx.text
    // 텍스트 변화를 감지하는 부분
        .bind(
            // 변화한 텍스트를 적용하는 부분
            to: label.rx.text
        ).disposed(by: disposeBag)
}




----


===== Observer, Observable
* RxSwift
** Reaction - Action => Reaction 하기 위해 Action을 감시함
** Observer => 관찰하는 주체(= 주어)
** Observerable => 관찰되는 대상(= 목적어)

* Subscribe, Emit, Dispose
** Subscribe: Observer가 Obserable를 구독함
** Observable가 이벤트 방출
** Dispose: Observable의 Event 발행이 Complete되면 Dispose함

* Observable
** 요소가 가지고 있는 이벤트를 계속 방출함
** Subscribers가 방출한 이벤트들에 대해 반응할 수 있음

* Observable Life Cycle 
** Next 
*** Interger 또는 Tap
** Error 
*** Observable 종료됨
** Completed 
*** Observable 종료됨
* Observable Events
** 열거형으로 구성됨

[source, swift]
----
public enum Event<Element> {
    case next(Element)
    case error(Swift.Error)
    case completed
}
----

image:../images/observable-life-cycle.png[]

===== API Response 관찰

[source, swift]
----
Observable<Model>.create { observer -> Disposable in
    API.getData(handler: { (model: Model?) in
        guard let model = model else {
            observer.on(Event.error(RxError.noElements))
            return
        }   

        observer.on(Event.next(model))
        observer.on(Event.completed)
    })

    return Disposables.create()
}.subscribe { (event: Event<Model>) in 
    switch event {
    case let .next(model):
        print(model)
    case let .error(error):
        print("error: \(error.localizedDescription)")
    case .completed:
        print("completed")
    }
}.disposed(by: disposeBag)
----

===== KVO => Observable 변환

[source, swift]
----
self.label.rx.observe(String.self, "text")
    .subscribe { (event: Event<String?>) in
        switch event {
        case .next(let text):
            print("label: \(text)")
        default:
            break
        }
    }.disposed(by: disposeBag)
----

===== Dispose
* dispose() => 즉시 처분
* DisposeBag => Disposable 들을 모아두다가 한번에 처분함

===== Observable 생성하는 방법
* just 
* from
* of
* empty => Complete Event만 방출함
* never => 아무런 이벤트가 발생하지 않음
* error => Error Event 1개 방출함
* create
* repeatElement
* interval 

===== PublishSubject
* Observer, Observable 동시 구현
** On, Subscribe 둘 다 할 수 있음
* 스스로 일어나는 이벤트가 아닐 때 사용함 => 이벤트를 외부에서 전달해주는 경우 사용함
* Delegate 대신 사용하기도 함

===== BehaviorSubject
* 초기값이 1개
* 마지막 Event를 꺼내올 수 있음
* Subscribe와 상관없이 데이터에 접근해서 사용해야 하는 경우 => Datasource

===== Transforming
* Map

[source, swift]
----
// 이벤트를 바꿈. E 타입에서 R 타입으로 바꿈
public func map<R>(_ transform: (E) -> R) -> Observable<R>

Observable.from([1, 2, 3, 4, 5].map { "\($0)" }
----

* flatMap

[source, swift]
----
// 이벤트를 다른 Observable로 바꿈
func flatMap<O: ObservableConvertibleType>(_ selector: @escaping (E) -> O) -> Observable<O.E>

// Button Tap Observable => API Call Observable로 바꿈
button.rx.tap.asObservable()
    .flatMap { _ -> Observable<Model> in
        API.api()
    }.subscribe(onNext: { (model: Model) in 
        // ...
    }, onError: { (error: Error) in
        // ...
    }).disposed(by: disposeBag)
----

* map을 사용하면 Observable이 아니라 nil을 리턴하지만, flatMap을 사용하면 Observable를 리턴해야 함

===== Filtering 
* filter

[source, swift]
----
// 조건에 맞는 이벤트만 통과함
Observable.from([1, 2, 3, 4, 5]).filter { (value) -> Bool in
    value % 2 == 0
}
----

* take(n)

[source, swift]
----
// 처움부터 n개까지의 이벤트만 가져옴
Observable.from([1, 2, 3, 4, 5].take(1)
----

* skip(n)

[source, swift]
----
// 처음부터 n개까지의 이벤트를 건너뜀
Observable.from([1, 2, 3, 4, 5].skip(1)
----

image:../images/skip.png[]

* distinctUntilChange

[source, swift]
----
// 이벤트 값이 변경될 때 이벤트를 발생시킴
Observable.from([true, true, false, false, true].distincUntilChange()
----

image:../images/distinctUntilChange.png[]

===== Combination
* merge => 이벤트 타입이 같은 Observable 여러 개를 합침. 합쳐진 이벤트는 이벤트 타입이 같은 것을 합쳤기 때문에 하나의 이벤트만 발생함
* zip => Observable에서 이벤트 한 쌍씩 순서대로 합쳐 이벤트를 발생함
* combineLatest => 두 개 Observable에서 가장 최근에 발생한 이벤트를 합침. 이벤트 타입이 달라도 됨
* withLatestFrom => 두 개 Observable를 합성하지만 하나 Observable에서 이벤트가 발생할 때 합성함. 이벤트가 발생하지 않으면 skip함

===== Bind
* 자주 사용할 subscribe 내용을 Binder로 만들어 두면 bind를 사용할 수 있음
** label.rx.text, UIView에서 사용하는 여러 Property
* subscribe Wrapper, subsribe와 bind 차이점은 bind는 값 바인딩 하나밖에 못하지만 subscribe에서 여러가지 일을 할 수 있음

[source, swift]
----
textField.rx.text.orEmpty.flatMap { text -> Observable<Int> in
    guard let intValue = Int(text) else { return Observable.empty() }
    
    return Observable.just(intValue)
}.flatMap { dan -> Observable<String> in
    // range를 통해 9개 이벤트가 발생하고 한개를 합쳐야 함
    return Observable<Int>.range(start: 1, count: 9).map { step -> String in
    return "\(dan) * \(step) = \(dan * step)"
    // Array, Dictionary가 가지고 있는 reduce 메서드와 비슷함
    }.reduce("", accumulator: { (answer, next) -> String in
        return answer + "\n" + next
    })
}
// .subscribe(onNext: { [weak self] (result) in    
//    self?.label.text = result
// })
// subscribe에서 결과를 바인드 하는 것과 같은 역할을 함
.bind(to: label.rx.text)
.disposed(by: disposeBag)
----

===== ControlProperty
* Data와 User Interface를 연결할 때 Rx Extension을 통해 사용함
* orEmpty 프로퍼티
** Optional인 경우 이벤트가 발생하지 않음

[source, swift]
----
textField.rx.text.orEmpty.flatMap { text -> Observable<Int> in
  guard let intValue = Int(text) else { return Observable.empty() }
    
  return Observable.just(intValue)
}.
// ...
----

===== 예제

image:../images/sum-of-digits.gif[24%, 24%]
image:../images/times-table-1.gif[24%, 24%]
image:../images/times-table-2.gif[24%, 24%]