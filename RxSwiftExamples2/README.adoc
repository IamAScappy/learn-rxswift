= RxSwiftExamples2

===== RxSwift, RxCocoa 적용
* UIImage

[source, swift]
----
func getImage(url: URL?) -> UIImage? {
    // ...
}

func getImage(url: URL?, handler: ((UIImage?) -> Void)) -> Void {
    // ...
}

func getImage(url: URL?) -> Observable<UIImage> { 
    // ...
}
----

* TextField

[source, swift]
----
// Before
override func viewDidLoad() {
    super.viewDidLoad()
    textField.addTarget(self,
                        action: #selector(textFieldDidChange(textField:)),
                            for: UIControlEvents.editingChanged)
}

@objc func textFieldDidChange(textField: UITextField){
    label.text = textField.text
}

// After
override func viewDidLoad() {
    textField.rx.text
    // 텍스트 변화를 감지하는 부분
        .bind(
            // 변화한 텍스트를 적용하는 부분
            to: label.rx.text
        ).disposed(by: disposeBag)
}
----

* API Response 관찰

[source, swift]
----
Observable<Model>.create { observer -> Disposable in
    API.getData(handler: { (model: Model?) in
        guard let model = model else {
            observer.on(Event.error(RxError.noElements))
            return
        }   

        observer.on(Event.next(model))
        observer.on(Event.completed)
    })

    return Disposables.create()
}.subscribe { (event: Event<Model>) in 
    switch event {
    case let .next(model):
        print(model)
    case let .error(error):
        print("error: \(error.localizedDescription)")
    case .completed:
        print("completed")
    }
}.disposed(by: disposeBag)
----

* KVO => Observable 변환

[source, swift]
----
self.label.rx.observe(String.self, "text")
    .subscribe { (event: Event<String?>) in
        switch event {
        case .next(let text):
            print("label: \(text)")
        default:
            break
        }
    }.disposed(by: disposeBag)
----


===== Observer, Observable
* RxSwift
** Reaction - Action => Reaction 하기 위해 Action을 감시함
** Observer => 관찰하는 주체(= 주어)
** Observerable => 관찰되는 대상(= 목적어)

* Subscribe, Emit, Dispose
** Subscribe => Observer가 Obserable를 구독함
** Observable가 이벤트 방출
** Dispose => Observable의 Event 발행이 Complete되면 Dispose함

* Observable
** 요소가 가지고 있는 이벤트를 계속 방출함
** Subscribers가 방출한 이벤트들에 대해 반응할 수 있음

* Observable Life Cycle 
** Next => Interger 또는 Tap
** Error => Observable 종료됨
** Completed => Observable 종료됨
* Observable Events
** 열거형으로 구성됨

[source, swift]
----
public enum Event<Element> {
    case next(Element)
    case error(Swift.Error)
    case completed
}
----

image:../images/observable-life-cycle.png[]


===== Dispose
* dispose() => 즉시 처분
* DisposeBag => Disposable 들을 모아두다가 한번에 처분함

===== Observable 생성
* just 
* from
* of
* empty => Complete Event만 방출함
* never => 아무런 이벤트가 발생하지 않음
* error => Error Event 1개 방출함
* create
* repeatElement
* interval 

===== Subjects
* PublishSubject
** Observer, Observable 동시 구현
*** On, Subscribe 둘 다 할 수 있음
** 스스로 일어나는 이벤트가 아닐 때 사용함 => 이벤트를 외부에서 전달해주는 경우 사용함
** Delegate 대신 사용하기도 함
* BehaviorSubject
** 초기값이 1개
** 마지막 Event를 꺼내올 수 있음
** Subscribe와 상관없이 데이터에 접근해서 사용해야 하는 경우 => Datasource

===== Transforming
* http://rxmarbles.com/#map[map]

[source, swift]
----
// 이벤트를 바꿈. E 타입에서 R 타입으로 바꿈
public func map<R>(_ transform: (E) -> R) -> Observable<R>

Observable.from([1, 2, 3, 4, 5].map { "\($0)" }
----

* flatMap

[source, swift]
----
// 이벤트를 다른 Observable로 바꿈
// map을 사용하면 Observable이 아니라 nil을 리턴하지만, flatMap을 사용하면 Observable를 리턴해야 함 
func flatMap<O: ObservableConvertibleType>(_ selector: @escaping (E) -> O) -> Observable<O.E>

// Button Tap Observable => API Call Observable로 바꿈
button.rx.tap.asObservable()
    .flatMap { _ -> Observable<Model> in
        API.api()
    }.subscribe(onNext: { (model: Model) in 
        // ...
    }, onError: { (error: Error) in
        // ...
    }).disposed(by: disposeBag)
----

* window

[source, swift]
----
// window, buffer와 아주 밀접함. 거의 같지만 다른 점은 Observable 방출한다는 차이점이 존재함
let numberObservable = Observable.merge(numberObservables)
    
let inputtedNumberObservable = numberObservable.window(timeSpan: 3600 * 24, count: 2, scheduler: MainScheduler.instance)
    .flatMap { window -> Observable<Int> in
        return window.scan(0, accumulator: { (anwser, event) -> Int in
            return (anwser * 10) + event
        })
    }
----

===== Filtering 
* http://rxmarbles.com/#filter[filter]

[source, swift]
----
// 조건에 맞는 이벤트만 통과함
Observable.from([1, 2, 3, 4, 5]).filter { (value) -> Bool in
    value % 2 == 0
}
----

* http://rxmarbles.com/#take[take(n)]

[source, swift]
----
// 처움부터 n개까지의 이벤트만 가져옴
Observable.from([1, 2, 3, 4, 5].take(1)
----

* http://rxmarbles.com/#skip[skip(n)]

[source, swift]
----
// 처음부터 n개까지의 이벤트를 건너뜀
Observable.from([1, 2, 3, 4, 5].skip(1)
----

* http://rxmarbles.com/#distinctUntilChanged[distinctUntilChange]

[source, swift]
----
// 이벤트 값이 변경될 때 이벤트를 발생시킴
Observable.from([true, true, false, false, true].distincUntilChange()
----

===== Combination
* http://rxmarbles.com/#merge[merge]

[source, swift]
----
// 이벤트 타입이 같은 Observable 여러 개를 합침. 합쳐진 이벤트는 이벤트 타입이 같은 것을 합쳤기 때문에 하나의 이벤트만 발생함
let numberObservables = numberButtons.enumerated().map { (index, button) -> Observable<Int> in
        button.rx.tap.map { index + 1 }
    }
    
let numberObservable = Observable.merge(numberObservables)
----


* http://rxmarbles.com/#zip[zip] 

[source, swift]
----
// Observable에서 이벤트 한 쌍씩 순서대로 합쳐 이벤트를 발생함
----

* http://rxmarbles.com/#combineLatest[combineLatest]

[source, swift]
----
// 두 개 Observable에서 가장 최근에 발생한 이벤트를 합침. 이벤트 타입이 달라도 됨
Observable.combineLatest([aValueObservable, bValueObservable, cValueObservable]) { (values) -> Int in
    return values.reduce(0, +)
}.map { "\($0)" }.subscribe { [weak self] event in
    switch event {
    case .next(let value):
        self?.resultLabel.text = value
    default:
        break
    }
}.disposed(by: disposeBag)
----

* http://rxmarbles.com/#withLatestFrom[withLatestFrom] 
 
[source, swift]
----
// 두 개 Observable를 합성하지만 하나 Observable에서 이벤트가 발생할 때 합성함. 이벤트가 발생하지 않으면 skip함
// 사이드 효과를 없애줌
secondNumberObservable
    .withLatestFrom(firstNumberObservable) { (second, first) -> Int in
        return second * first
    }
    .map { "\($0)" }
    .bind(to: resultNumberLabel.rx.text)
    .disposed(by: disposeBag)
----

===== Binding
* 자주 사용할 subscribe 내용을 Binder로 만들어 두면 bind를 사용할 수 있음
** label.rx.text, UIView에서 사용하는 여러 Property

[source, swift]
----
// bind
// - subscribe Wrapper, subsribe와 bind 차이점은 bind는 값 바인딩 하나밖에 못하지만 subscribe에서 여러가지 일을 할 수 있음
textField.rx.text.orEmpty.flatMap { text -> Observable<Int> in
    guard let intValue = Int(text) else { return Observable.empty() }
    
    return Observable.just(intValue)
}.flatMap { dan -> Observable<String> in
    return Observable<Int>.range(start: 1, count: 9).map { step -> String in
        return "\(dan) * \(step) = \(dan * step)"
    }.reduce("", accumulator: { (answer, next) -> String in
        return answer + "\n" + next
    })
}
// .subscribe(onNext: { [weak self] (result) in    
//    self?.label.text = result
// })
// subscribe에서 결과를 바인드 하는 것과 같은 역할을 함
.bind(to: label.rx.text)
.disposed(by: disposeBag)

// Binder
// - Boxing: view.rx.animation
// - Binder 안에서 코드가 길어지는 것을 경계해야 함
extension Reactive where Base: UIView {
    var animation: Binder<Animation> {
        return Binder(self.base, binding: { (view, animation) in
            UIView.animate(withDuration: 0.5) {
                view.transform = animation.transform(view.transform)
            }
        })
    }
}
----

===== ControlProperty
* Data와 User Interface를 연결할 때 Rx Extension을 통해 사용함

[source, swift]
----
// orEmpty
// - Optional인 경우 이벤트가 발생하지 않음
textField.rx.text.orEmpty.flatMap { text -> Observable<Int> in
  guard let intValue = Int(text) else { return Observable.empty() }
    
  return Observable.just(intValue)
}.
// ...
----