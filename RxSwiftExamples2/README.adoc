= RxSwiftExamples2

===== RxSwift, RxCocoa 적용
* UIImage

[source, swift]
----
func getImage(url: URL?) -> UIImage? {
    // ...
}

func getImage(url: URL?, handler: ((UIImage?) -> Void)) -> Void {
    // ...
}

func getImage(url: URL?) -> Observable<UIImage> { 
    // ...
}
----

* TextField

[source, swift]
----
// Before
override func viewDidLoad() {
    super.viewDidLoad()
    textField.addTarget(self,
                        action: #selector(textFieldDidChange(textField:)),
                            for: UIControlEvents.editingChanged)
}

@objc func textFieldDidChange(textField: UITextField){
    label.text = textField.text
}

// After
override func viewDidLoad() {
    textField.rx.text
    // 텍스트 변화를 감지하는 부분
        .bind(
            // 변화한 텍스트를 적용하는 부분
            to: label.rx.text
        ).disposed(by: disposeBag)
}
----

* API Response 관찰

[source, swift]
----
Observable<Model>.create { observer -> Disposable in
    API.getData(handler: { (model: Model?) in
        guard let model = model else {
            observer.on(Event.error(RxError.noElements))
            return
        }   

        observer.on(Event.next(model))
        observer.on(Event.completed)
    })

    return Disposables.create()
}.subscribe { (event: Event<Model>) in 
    switch event {
    case let .next(model):
        print(model)
    case let .error(error):
        print("error: \(error.localizedDescription)")
    case .completed:
        print("completed")
    }
}.disposed(by: disposeBag)
----

* KVO => Observable 변환

[source, swift]
----
self.label.rx.observe(String.self, "text")
    .subscribe { (event: Event<String?>) in
        switch event {
        case .next(let text):
            print("label: \(text)")
        default:
            break
        }
    }.disposed(by: disposeBag)
----


===== Observer, Observable
* RxSwift
** Reaction - Action => Reaction 하기 위해 Action을 감시함
** Observer => 관찰하는 주체(= 주어)
** Observerable => 관찰되는 대상(= 목적어)

* Subscribe, Emit, Dispose
** Subscribe => Observer가 Obserable를 구독함
** Observable가 이벤트 방출
** Dispose => Observable의 Event 발행이 Complete되면 Dispose함

* Observable
** 요소가 가지고 있는 이벤트를 계속 방출함
** Subscribers가 방출한 이벤트들에 대해 반응할 수 있음

* Observable Life Cycle 
** Next => Interger 또는 Tap
** Error => Observable 종료됨
** Completed => Observable 종료됨
* Observable Events
** 열거형으로 구성됨

[source, swift]
----
public enum Event<Element> {
    case next(Element)
    case error(Swift.Error)
    case completed
}
----

image:../images/observable-life-cycle.png[]


===== Dispose
* dispose() => 즉시 처분
* DisposeBag => Disposable 들을 모아두다가 한번에 처분함

===== Creating Observables
* just 
* from
* of
* empty => Complete Event만 방출함
* never => 아무런 이벤트가 발생하지 않음
* error => Error Event 1개 방출함
* create
* repeatElement
* interval 

===== Subjects
* PublishSubject
** Observer, Observable 동시 구현
*** On, Subscribe 둘 다 할 수 있음
** 스스로 일어나는 이벤트가 아닐 때 사용함 => 이벤트를 외부에서 전달해주는 경우 사용함
** Delegate 대신 사용하기도 함
* BehaviorSubject
** 초기값이 1개
** 마지막 Event를 꺼내올 수 있음
** Subscribe와 상관없이 데이터에 접근해서 사용해야 하는 경우 => Datasource

===== Transforming Observables
* https://reactivex.io/documentation/operators/map.html[Map]

[source, swift]
----
// 이벤트를 바꿈. E 타입에서 R 타입으로 바꿈
public func map<R>(_ transform: (E) -> R) -> Observable<R>

Observable.from([1, 2, 3, 4, 5].map { "\($0)" }
----

* https://reactivex.io/documentation/operators/groupby.html[FlatMap]

[source, swift]
----
// 이벤트를 다른 Observable로 바꿈
// map을 사용하면 Observable이 아니라 nil을 리턴하지만, flatMap을 사용하면 Observable를 리턴해야 함 
func flatMap<O: ObservableConvertibleType>(_ selector: @escaping (E) -> O) -> Observable<O.E>

// Button Tap Observable => API Call Observable로 바꿈
button.rx.tap.asObservable()
    .flatMap { _ -> Observable<Model> in
        API.api()
    }.subscribe(onNext: { (model: Model) in 
        // ...
    }, onError: { (error: Error) in
        // ...
    }).disposed(by: disposeBag)
----

* https://reactivex.io/documentation/operators/window.html[Window]

[source, swift]
----
// window, buffer와 아주 밀접함. 거의 같지만 다른 점은 Observable 방출한다는 차이점이 존재함
let numberObservable = Observable.merge(numberObservables)
    
let inputtedNumberObservable = numberObservable.window(timeSpan: 3600 * 24, count: 2, scheduler: MainScheduler.instance)
    .flatMap { window -> Observable<Int> in
        return window.scan(0, accumulator: { (anwser, event) -> Int in
            return (anwser * 10) + event
        })
    }
----

===== Filtering Observables
* https://reactivex.io/documentation/operators/filter.html[Filter]

[source, swift]
----
// 조건에 맞는 이벤트만 통과함
Observable.from([1, 2, 3, 4, 5]).filter { (value) -> Bool in
    value % 2 == 0
}
----

* https://reactivex.io/documentation/operators/take.html[Take]

[source, swift]
----
// 처움부터 n개까지의 이벤트만 가져옴
Observable.from([1, 2, 3, 4, 5].take(1)
----

* https://reactivex.io/documentation/operators/skip.html[Skip]

[source, swift]
----
// 처음부터 n개까지의 이벤트를 건너뜀
Observable.from([1, 2, 3, 4, 5].skip(1)
----

* http://rxmarbles.com/#distinctUntilChanged[distinctUntilChanged]

[source, swift]
----
// 이벤트 값이 변경될 때 이벤트를 발생시킴
Observable.from([true, true, false, false, true].distinctUntilChanged()
----

===== Combination
* https://reactivex.io/documentation/operators/merge.html[Merge]

[source, swift]
----
// 이벤트 타입이 같은 Observable 여러 개를 합침. 합쳐진 이벤트는 이벤트 타입이 같은 것을 합쳤기 때문에 하나의 이벤트만 발생함
let numberObservables = numberButtons.enumerated().map { (index, button) -> Observable<Int> in
        button.rx.tap.map { index + 1 }
    }
    
let numberObservable = Observable.merge(numberObservables)
----


* https://reactivex.io/documentation/operators/zip.html[Zip] 

[source, swift]
----
// Observable에서 이벤트 한 쌍씩 순서대로 합쳐 이벤트를 발생함
----

* https://reactivex.io/documentation/operators/combinelatest.html[CombineLatest]

[source, swift]
----
// 두 개 Observable에서 가장 최근에 발생한 이벤트를 합침. 이벤트 타입이 달라도 됨
Observable.combineLatest([aValueObservable, bValueObservable, cValueObservable]) { (values) -> Int in
    return values.reduce(0, +)
}.map { "\($0)" }.subscribe { [weak self] event in
    switch event {
    case .next(let value):
        self?.resultLabel.text = value
    default:
        break
    }
}.disposed(by: disposeBag)
----

* http://rxmarbles.com/#withLatestFrom[WithLatestFrom] 
 
[source, swift]
----
// 두 개 Observable를 합성하지만 하나 Observable에서 이벤트가 발생할 때 합성함. 이벤트가 발생하지 않으면 skip함
// 사이드 효과를 없애줌
secondNumberObservable
    .withLatestFrom(firstNumberObservable) { (second, first) -> Int in
        return second * first
    }
    .map { "\($0)" }
    .bind(to: resultNumberLabel.rx.text)
    .disposed(by: disposeBag)
----

===== Binding
* 자주 사용할 subscribe 내용을 Binder로 만들어 두면 bind를 사용할 수 있음
** label.rx.text, UIView에서 사용하는 여러 Property

[source, swift]
----
// bind
// - subscribe Wrapper, subsribe와 bind 차이점은 bind는 값 바인딩 하나밖에 못하지만 subscribe에서 여러가지 일을 할 수 있음
textField.rx.text.orEmpty.flatMap { text -> Observable<Int> in
    guard let intValue = Int(text) else { return Observable.empty() }
    
    return Observable.just(intValue)
}.flatMap { dan -> Observable<String> in
    return Observable<Int>.range(start: 1, count: 9).map { step -> String in
        return "\(dan) * \(step) = \(dan * step)"
    }.reduce("", accumulator: { (answer, next) -> String in
        return answer + "\n" + next
    })
}
// .subscribe(onNext: { [weak self] (result) in    
//    self?.label.text = result
// })
// subscribe에서 결과를 바인드 하는 것과 같은 역할을 함
.bind(to: label.rx.text)
.disposed(by: disposeBag)

// Binder
// - Boxing: view.rx.animation
// - Binder 안에서 코드가 길어지는 것을 경계해야 함
extension Reactive where Base: UIView {
    var animation: Binder<Animation> {
        return Binder(self.base, binding: { (view, animation) in
            UIView.animate(withDuration: 0.5) {
                view.transform = animation.transform(view.transform)
            }
        })
    }
}
----

===== Observable Utility Operators
* https://reactivex.io/documentation/operators/observeon.html[ObserveOn]
** Observable이 Observer에게 알림을 보낼 때 사용할 스레드를 명시함

[source, swift]
----
goButton.rx.tap.asObservable().flatMap { [weak self] _ -> Observable<Void> in
    return self?.rx.showAlert(title: "다운로드", message: "다운로드 하시겠습니까?") ?? Observable.empty()

// SerialDispatchQueueScheduler: Main에서 Background로 넘어감
}.observeOn(SerialDispatchQueueScheduler(qos: .background))
----

* https://reactivex.io/documentation/operators/subscribeon.html[SubscribeOn]
** 다른 스케줄러를 지정해서 Observable이 처리해야 할 연산자들을 실행함
** `[ReactiveX][RxSwift]observeOn, subscribeOn – 작업 스레드 지정하기 링크 참고`
** `예제로 시작하는 RxSwift #4 – 멀티스레딩 링크 참고`

===== Schedular
* https://reactivex.io/documentation/scheduler.html[Schedular]
** Operator Chaining에서 멀티 스레드를 적용하고 싶다면 스케줄을 지정하면 됨
* 종류
** CurrentThreadScheduler => 현재 스레드에 있는 작업 단위들의 스케쥴. 기본 스케줄
** MainScheduler => 메인 스레드에서 작업하는 스케줄. UI 작업에서 많이 사용함. SerialDispatchQueueScheduler의 인스턴스 중 하나
** SerialDispatchQueueScheduler => 특정 _dispatch_queue_t_ 에서 실행되어야 하는 추상적인 작업에서 사용함. ConcurrentDispatchQueueScheduler에서 전달된 경우도 SerialDispatchQueueScheduler로 변환함. observeOn을 위해 특정 최적화를 가능하게 함
** ConcurrentDispatchQueueScheduler => 특정 _dispatch_queue_t_ 에서 실행되어야 하는 추상적인 작업에서 사용함. SerialDispatchQueueScheduler 보내도 아무런 문제가 발생하지 않음. Background 작업에서 사용하는 것이 적합함
** OperationQueueScheduler => _NSOperationQueue_ 에서 사용함. 어떤 큰 덩어리의 작업이 있고 이 작업이 백그라운드에서 실행되어야 하며 _maxConcurrentOperationCount_ 이용해서 Concurrent 처리 과정에서 미세 조정하고 싶을 때 적합함

===== ControlProperty
* Data와 User Interface를 연결할 때 Rx Extension을 통해 사용함

[source, swift]
----
// orEmpty
// - Optional인 경우 이벤트가 발생하지 않음
textField.rx.text.orEmpty.flatMap { text -> Observable<Int> in
  guard let intValue = Int(text) else { return Observable.empty() }
    
  return Observable.just(intValue)
}.
// ...
----

=== 참고
* http://blog.weirdx.io/post/26576[[ReactiveX][RxSwift]observeOn, subscribeOn – 작업 스레드 지정하기]
* https://pilgwon.github.io/blog/2017/10/14/RxSwift-By-Examples-4-Multithreading.html[예제로 시작하는 RxSwift #4 – 멀티스레딩]
* https://www.thedroidsonroids.com/blog/ios/rxswift-examples-4-multithreading/[RxSwift by Examples #4 – Multithreading.]