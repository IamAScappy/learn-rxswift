= RxSwiftExamples2

===== RxSwift, RxCocoa 적용
* UIImage

[source, swift]
----
func getImage(url: URL?) -> UIImage? {
    // ...
}

func getImage(url: URL?, handler: ((UIImage?) -> Void)) -> Void {
    // ...
}

func getImage(url: URL?) -> Observable<UIImage> { 
    // ...
}
----

* TextField

[source, swift]
----
// Before
override func viewDidLoad() {
    super.viewDidLoad()
    textField.addTarget(self,
                        action: #selector(textFieldDidChange(textField:)),
                            for: UIControlEvents.editingChanged)
}

@objc func textFieldDidChange(textField: UITextField){
    label.text = textField.text
}


// After
override func viewDidLoad() {
    textField.rx.text
    // 텍스트 변화를 감지하는 부분
        .bind(
            // 변화한 텍스트를 적용하는 부분
            to: label.rx.text
        ).disposed(by: disposeBag)
}
----

* API Response 관찰

[source, swift]
----
Observable<Model>.create { observer -> Disposable in
    API.getData(handler: { (model: Model?) in
        guard let model = model else {
            observer.on(Event.error(RxError.noElements))
            return
        }   

        observer.on(Event.next(model))
        observer.on(Event.completed)
    })

    return Disposables.create()
}.subscribe { (event: Event<Model>) in 
    switch event {
    case let .next(model):
        print(model)
    case let .error(error):
        print("error: \(error.localizedDescription)")
    case .completed:
        print("completed")
    }
}.disposed(by: disposeBag)
----

* KVO => Observable 변환

[source, swift]
----
self.label.rx.observe(String.self, "text")
    .subscribe { (event: Event<String?>) in
        switch event {
        case .next(let text):
            print("label: \(text)")
        default:
            break
        }
    }.disposed(by: disposeBag)
----


===== Observer, Observable
* Observer
** 관찰하는 주체(= 주어) 
** Reaction - Action: Reaction 하기 위해 Action을 감시함

* Observable
** 관찰되는 대상(= 목적어)
** 요소가 가지고 있는 이벤트를 계속 방출함
** Subscribers가 방출한 이벤트들에 대해 반응할 수 있음

* Observable Life Cycle 
** Next => Interger 또는 Tap
** Error => Observable 종료됨
** Completed => Observable 종료됨
* Observable Events
** 열거형으로 구성됨

[source, swift]
----
public enum Event<Element> {
    case next(Element)
    case error(Swift.Error)
    case completed
}
----

image:../images/observable-life-cycle.png[]

===== Subscribe, Emit, Dispose
* Subscribe => Observer가 Obserable를 구독함
* Emit => Observable가 이벤트 방출
* Dispose => Observable의 Event 발행이 Complete되면 Dispose함


===== Dispose
* dispose() => 즉시 처분
* DisposeBag => Disposable 들을 모아두다가 한번에 처분함

===== Creating Observables
* just 
* from
* of
* empty => Complete Event만 방출함
* never => 아무런 이벤트가 발생하지 않음
* error => Error Event 1개 방출함
* create
* repeatElement
* interval 

===== Subjects
* PublishSubject
** Observer, Observable 동시 구현
** On, Subscribe 둘 다 할 수 있음
** Subscribe 이 후, Observable이 보낸 이벤트를 전달받음
** 스스로 일어나는 이벤트가 아닐 때 사용함 => 이벤트를 외부에서 전달해주는 경우 사용함. Delegate로 사용할 수 있음
* ReplaySubject
** Subscribe 전에 발생한 이벤트를 버퍼 사이즈 만큼 넣고, 버퍼에 있던 이벤트를 subscribe 후 전달함. 버퍼 크기를 설정한 만큼 구독 후 이벤트를 전달함
* BehaviorSubject
** 초기값이 1개
** Subscribe 후, 최신 Event를 전달 받음
** Subscribe와 상관없이 데이터에 접근해서 사용해야 하는 경우 => Datasource로 사용할 수 있음

===== Transforming Observables
* https://reactivex.io/documentation/operators/map.html[Map]

[source, swift]
----
// 이벤트를 바꿈. E 타입에서 R 타입으로 바꿈
public func map<R>(_ transform: (E) -> R) -> Observable<R>

Observable.from([1, 2, 3, 4, 5].map { "\($0)" }
----

* https://reactivex.io/documentation/operators/groupby.html[FlatMap]

[source, swift]
----
// 이벤트를 다른 Observable로 바꿈
// map을 사용하면 Observable이 아니라 nil을 리턴하지만, flatMap을 사용하면 Observable를 리턴해야 함 
func flatMap<O: ObservableConvertibleType>(_ selector: @escaping (E) -> O) -> Observable<O.E>

// Button Tap Observable => API Call Observable로 바꿈
button.rx.tap.asObservable()
    .flatMap { _ -> Observable<Model> in
        API.api()
    }.subscribe(onNext: { (model: Model) in 
        // ...
    }, onError: { (error: Error) in
        // ...
    }).disposed(by: disposeBag)
----

* https://reactivex.io/documentation/operators/window.html[Window]

[source, swift]
----
// window, buffer와 아주 밀접함. 거의 같지만 다른 점은 Observable 방출한다는 차이점이 존재함
// 이벤트 합치기 용도
// 앞부분에서 subscibe, 뒷부분에서 completed. 그래서 시작과 끝부분을 이용할 수 있음
// window 단위로 끊어짐. window를 작은 Observable를 생각하면 됨

// Scan
// - 이전 이벤트와 현재 들어온 이벤트를 가지고 현재 발행할 새 이벤트를 만듦
// - answer ⇒ 이전 값
// - element ⇒ 현재 값
// - window로 비밀번호 자리수로 확인할 수 있음. scan + window 조합
let numberObservable = Observable.merge(numberObservables)
    
let inputtedNumberObservable = numberObservable.window(timeSpan: 3600 * 24, count: 2, scheduler: MainScheduler.instance)
    .flatMap { window -> Observable<Int> in
        return window.scan(0, accumulator: { (anwser, event) -> Int in
            return (anwser * 10) + event
        })
    }
----

* flatMapFirst, flatMapLatest

[source, swift]
----
button.rx.tap.flatMap {
    return apiCall
}

// 첫 번째 버튼에 대한 이벤트가 3번 발생, 두 번째 버튼에 대한 이벤트가 3번 발생, 세 번째 버튼에 대한 이벤트가 3번 발생
// flatMap은 이벤트가 섞임. 이벤트가 섞이지 않도록 해야 함
// 그래서 flatMapFirst, flatMapLatest가 있음
button.rx.tap.flatMap {
    return Observable<Int>
        .interval(1, scheduler: MainScheduler.instance)
        .take(1)
}

// flatMapFirst
// - 먼저 생성된 옵저버블이 끝나기 전까지 들어오는 이벤트는 무시함. 첫 번째 생성한 이벤트가 끝까지 일어남
// - 스크롤를 통해 처음 내용을 불러올 때, 페이지 로딩이 필요할 때 사용할 수 있음
// - API가 끝나기 전까지 다른 API를 부르지 않음

// fiatMapLatest
// - 이벤트가 들어오면 앞에 생성된 옵저버블을 무시함
// - 세 번째 이벤트는 끝까지 일어남
// - 예를 들어 카카오톡 외치기 같이 카톡에서 서버랑 유저의 정합성이 맞아야 하는 API는 아님. 빠르게 누르는 것이 중요함, Facebook Live 좋아요 같은 Reponse가 중요하지 않을 때 사용하는 것이 좋음
----

* Side Effect
** Side Effect가 있으면 안되는 곳
*** map
*** flatMap
*** 다른 형태로 바꾸는 것이기 때문에 Side Effect가 발생하면 안됨
** Side Effect가 있어도 괜찮은 곳
*** do
*** subcribe => subscribe이기 때문에 self 접근이 가능함

[source, swift]
----
// 클로저 처리와 인자로 처리하는 차이

// Side Effect가 발생할 수 있음
sendButton.rx.tap.flatmap { [weak self] in
    // 클로저 외부를 직접 전급
    send(message: self?.textField.text)
}

// withLatestFrom: Side Effect 해소
sendButton.rx.tap
    // 인자로 넣음
    .withLatestFrom(textField.rx.text)
    .flatMap { message in
        // 텍스트 매개변수로 받아옴
        send(message: message)
    }
----

===== Filtering Observables
* https://reactivex.io/documentation/operators/filter.html[Filter]

[source, swift]
----
// 조건에 맞는 이벤트만 통과함
Observable.from([1, 2, 3, 4, 5]).filter { (value) -> Bool in
    value % 2 == 0
}
----

* https://reactivex.io/documentation/operators/take.html[Take]

[source, swift]
----
// 처음부터 N 개까지 이벤트만 가져옴
Observable.from([1, 2, 3, 4, 5].take(1)
----

* https://reactivex.io/documentation/operators/skip.html[Skip]

[source, swift]
----
// 처음부터 N 개까지 이벤트를 건너뜀
Observable.from([1, 2, 3, 4, 5].skip(1)
----

* http://rxmarbles.com/#distinctUntilChanged[distinctUntilChanged]

[source, swift]
----
// 이벤트 값이 변경될 때 이벤트를 발생시킴
Observable.from([true, true, false, false, true].distinctUntilChanged()
----

===== Combining Observables
* https://reactivex.io/documentation/operators/merge.html[Merge]

[source, swift]
----
// 이벤트 타입이 같은 Observable 여러 개를 합침. 합쳐진 이벤트는 이벤트 타입이 같은 것을 합쳤기 때문에 하나의 이벤트만 발생함
let numberObservables = numberButtons.enumerated().map { (index, button) -> Observable<Int> in
        button.rx.tap.map { index + 1 }
    }
    
let numberObservable = Observable.merge(numberObservables)
----


* https://reactivex.io/documentation/operators/zip.html[Zip] 

[source, swift]
----
// Observable에서 이벤트 한 쌍씩 순서대로 합쳐 이벤트를 발생함
----

* https://reactivex.io/documentation/operators/combinelatest.html[CombineLatest]

[source, swift]
----
// 두 개 Observable에서 가장 최근에 발생한 이벤트를 합침. 이벤트 타입이 달라도 됨
Observable.combineLatest([aValueObservable, bValueObservable, cValueObservable]) { (values) -> Int in
    return values.reduce(0, +)
}.map { "\($0)" }.subscribe { [weak self] event in
    switch event {
    case .next(let value):
        self?.resultLabel.text = value
    default:
        break
    }
}.disposed(by: disposeBag)
----

* http://rxmarbles.com/#withLatestFrom[WithLatestFrom] 
 
[source, swift]
----
// 두 개 Observable를 합성하지만 하나 Observable에서 이벤트가 발생할 때 합성함. 이벤트가 발생하지 않으면 건너뜀
// 사이드 효과를 없애줌
secondNumberObservable
    .withLatestFrom(firstNumberObservable) { (second, first) -> Int in
        return second * first
    }
    .map { "\($0)" }
    .bind(to: resultNumberLabel.rx.text)
    .disposed(by: disposeBag)
----

* https://reactivex.io/documentation/operators/switch.html[Switch]

[source, swift]
----
// 여러 옵저버블을 하나의 옵저버블로 만듦. 내부 옵저버블을 새 옵저버블로 갈아치움
// subscribe 한 상태에서 아이디가 바뀐다면?
----

===== Connectable Observable Operators
* Observable을 공유하지 않으면 subscribe 횟수만큼 이벤트가 발생함. 예를 들어 API Call 하는 Observable가 여러 번 Subscribe 하면 API Call이 똑같이 여러 번 일어나게 됨
* https://reactivex.io/documentation/ko/operators/connect.html[Connect]
* https://reactivex.io/documentation/operators/publish.html[Publish]

[source, swift]
----
func publish() -> ConnectableObservable<E> {
   return self.multicast { PublishSubject() }
}


let observable = Observable<Int>
    .interval(0.3, scheduler: MainScheduler.instance).take(2).skip(1)
    .map { (element: Int) -> Int in
        print("map: \(element)")
        return element
    }

// publish: 일반 Observable를 공유 가능한 Observable로 변환함
let publishObservable = observable.publish()

publishObservable
    .subscribe(onNext: { element in
        print("publishObservable subscribe 1 : \(element)")
    }).disposed(by: disposeBag)

publishObservable
    .subscribe(onNext: { element in
        print("publishObservable subscribe 2 : \(element)")
    }).disposed(by: disposeBag)

// connect: subscriber가 항목을 배출할 수 있도록 공유되어 있는 Observable에게 명령을 내림
publishObservable.connect().disposed(by: disposeBag)
----

* https://reactivex.io/documentation/operators/replay.html[Replay]
* https://reactivex.io/documentation/operators/refcount.html[RefCount]

[source, swift]
----
// Observable이 이벤트 방출 후에 subscribe 하더라도 방출한 모든 이벤트들을 볼 수 있음
func replay(_ bufferSize: Int) -> ConnectableObservable<E> {
    return self.multicast { ReplaySubject.create(bufferSize: bufferSize) }
}

// Connect를 사용하지 않아도 일반 Observable가 연결 가능한 Observable처럼 동작함
let observable = Observable<Int>
    .interval(0.3, scheduler: MainScheduler.instance).take(3).skip(1)
    .map { (element: Int) -> Int in
        print("map: \(element)")
        return element
    }

let refCountedPublishObservable = observable.publish().refCount()

refCountedPublishObservable
    .subscribe(onNext: { element in
        print("refCountedPublishObservable subscribe 1 : \(element)")
    }).disposed(by: disposeBag)

refCountedPublishObservable
    .subscribe(onNext: { element in
        print("refCountedPublishObservable subscribe 2 : \(element)")
    }).disposed(by: disposeBag)


// xs.subscribe 를 3번 만들면 새로운 Subscriber를 만듬. 결론은 3개의 새로운 Subscriber가 생김. 3개에 대한 이벤트 생성 시간이 각각 다름
let xs = Observable.deferred { () -> Observable<TimeInterval> in
        print("Performing work ...")
        return Observable.just(Date().timeIntervalSince1970)
    }.replay(1)

_ = xs.subscribe(onNext: { print("next \($0)") }, onCompleted: { print("completed\n") })
_ = xs.subscribe(onNext: { print("next \($0)") }, onCompleted: { print("completed\n") })
_ = xs.subscribe(onNext: { print("next \($0)") }, onCompleted: { print("completed\n") })
xs.connect().disposed(by: disposeBag)


let xs = Observable.deferred { () -> Observable<TimeInterval> in
    print("Performing work ...")
        return Observable.just(Date().timeIntervalSince1970)
    }
    // replay(1)를 통해 이벤트를 공유하고 있다가 1개를 반환함
    // refCount를 레퍼런스 카운팅라고 생각하면 됨. subscribe 하면 refCount() 1이 되었다가 0이 됨
    .replay(1).refCount()

_ = xs.subscribe(onNext: { print("next \($0)") }, onCompleted: { print("completed\n") })
_ = xs.subscribe(onNext: { print("next \($0)") }, onCompleted: { print("completed\n") })
_ = xs.subscribe(onNext: { print("next \($0)") }, onCompleted: { print("completed\n") })
----

* Share

[source, swift]
----
// Share - forever
// - observable를 공유하기 위해 사용함. 잘 사용하지 않음. 종료된 예전 값을 가져와서 사용하는 케이스가 잘 없음
// - 채팅방에서 메세지 작업 중에서 메세지를 공유하기 위해서 share를 쓰는 것이 좋음
// - replay 0인지 1인지 고민하면 됨
// - TabelView가 있으면 DataSource에 Bind함. DataSource에 원 글과 댓글이 존재함. 댓글과 원글의 DataSource를 공유하기 위해 사용할 수도 있음

// Share - whileConnected
// - 생각보다 사용할 일이 없음
func share(replay: Int = 0, scope: SubjectLifetimeScope = .whileConnected)
        -> Observable<E> {
        switch scope {
        case .forever:
            switch replay {
            case 0: return self.multicast(PublishSubject()).refCount()
            default: return
                 self.multicast(ReplaySubject.create(bufferSize: replay)).refCount()
            }
        case .whileConnected:
            switch replay {
            case 0: return ShareWhileConnected(source: self.asObservable())
            case 1: return ShareReplay1WhileConnected(source: self.asObservable())
            default: return self.multicast(makeSubject: {
                        ReplaySubject.create(bufferSize: replay) }).refCount()
                    }
            }
        }
}
----

===== Binding
* 자주 사용할 subscribe 내용을 Binder로 만들어 두면 bind를 사용할 수 있음
** label.rx.text, UIView에서 사용하는 여러 Property

[source, swift]
----
// bind
// - subscribe Wrapper, subsribe와 bind 차이점은 bind는 값 바인딩 하나밖에 못하지만 subscribe에서 여러가지 일을 할 수 있음
textField.rx.text.orEmpty.flatMap { text -> Observable<Int> in
    guard let intValue = Int(text) else { return Observable.empty() }
    
    return Observable.just(intValue)
}.flatMap { dan -> Observable<String> in
    return Observable<Int>.range(start: 1, count: 9).map { step -> String in
        return "\(dan) * \(step) = \(dan * step)"
    }.reduce("", accumulator: { (answer, next) -> String in
        return answer + "\n" + next
    })
}
// .subscribe(onNext: { [weak self] (result) in    
//    self?.label.text = result
// })
// subscribe에서 결과를 바인드 하는 것과 같은 역할을 함
.bind(to: label.rx.text)
.disposed(by: disposeBag)


// Binder
// - Boxing: view.rx.animation
// - Binder 안에서 코드가 길어지는 것을 경계해야 함
extension Reactive where Base: UIView {
    var animation: Binder<Animation> {
        return Binder(self.base, binding: { (view, animation) in
            UIView.animate(withDuration: 0.5) {
                view.transform = animation.transform(view.transform)
            }
        })
    }
}
----

===== Observable Utility Operators
* https://reactivex.io/documentation/operators/observeon.html[ObserveOn]

[source, swift]
----
// Observable이 Observer에게 알림을 보낼 때 사용할 스레드를 명시함
goButton.rx.tap.asObservable().flatMap { [weak self] _ -> Observable<Void> in
    return self?.rx.showAlert(title: "다운로드", message: "다운로드 하시겠습니까?") ?? Observable.empty()

// SerialDispatchQueueScheduler: Main에서 Background로 넘어감
}.observeOn(SerialDispatchQueueScheduler(qos: .background))
----

* https://reactivex.io/documentation/operators/subscribeon.html[SubscribeOn]

[source, swift]
----
// 다른 스케줄러를 지정해서 Observable이 처리해야 할 연산자들을 실행함
----

* `[ReactiveX][RxSwift]observeOn, subscribeOn – 작업 스레드 지정하기 링크 참고`
* `예제로 시작하는 RxSwift #4 – 멀티스레딩 링크 참고`

===== scheduler
* https://reactivex.io/documentation/scheduler.html[scheduler]
** Operator Chaining에서 멀티 스레드를 적용하고 싶다면 스케줄을 지정하면 됨
* 종류
** CurrentThreadScheduler(Serial) => 현재 스레드에 있는 작업 단위들의 스케쥴. 기본 스케줄
** MainScheduler(Serial) => 메인 스레드에서 작업하는 스케줄. UI 작업에서 많이 사용함. SerialDispatchQueueScheduler의 인스턴스 중 하나
** SerialDispatchQueueScheduler(Serial) => 특정 _dispatch_queue_t_ 에서 실행되어야 하는 추상적인 작업에서 사용함. ConcurrentDispatchQueueScheduler에서 전달된 경우도 SerialDispatchQueueScheduler로 변환함. observeOn을 위해 특정 최적화를 가능하게 함
** ConcurrentDispatchQueueScheduler(Concurrent) => 특정 _dispatch_queue_t_ 에서 실행되어야 하는 추상적인 작업에서 사용함. SerialDispatchQueueScheduler 보내도 아무런 문제가 발생하지 않음. Background 작업에서 사용하는 것이 적합함
** OperationQueueScheduler(Concurrent) => _NSOperationQueue_ 에서 사용함. 어떤 큰 덩어리의 작업이 있고 이 작업이 백그라운드에서 실행되어야 하며 _maxConcurrentOperationCount_ 이용해서 Concurrent 처리 과정에서 미세 조정하고 싶을 때 적합함
* https://github.com/yuaming/learn-rxswift/issues/3[Atomic, Nonatomic 정리]

===== ControlProperty
* Data와 User Interface를 연결할 때 Rx Extension을 통해 사용함

[source, swift]
----
// orEmpty
// - Optional인 경우 이벤트가 발생하지 않음
textField.rx.text.orEmpty.flatMap { text -> Observable<Int> in
  guard let intValue = Int(text) else { return Observable.empty() }
    
  return Observable.just(intValue)
}.
// ...
----

=== 참고
* http://blog.weirdx.io/post/26576[observeOn, subscribeOn – 작업 스레드 지정하기]
* https://pilgwon.github.io/blog/2017/10/14/RxSwift-By-Examples-4-Multithreading.html[예제로 시작하는 RxSwift #4 – 멀티스레딩]
* https://www.thedroidsonroids.com/blog/ios/rxswift-examples-4-multithreading/[RxSwift by Examples #4 – Multithreading.]
* https://reactivex.io/documentation/observable.html[RxSwift: Observable]
* https://reactivex.io/documentation/operators.html[RxSwift: Operators]
* https://reactivex.io/documentation/subject.html[RxSwift: Subject]
* https://reactivex.io/documentation/single.html[RxSwift: Single]
* https://reactivex.io/documentation/scheduler.html[RxSwift: Scheduler]